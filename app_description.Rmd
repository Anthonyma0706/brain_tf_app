---
title: "Description of joint cortex app"
author: "Anthony Ma"
date: "13/05/2020"
output:
  html_document:
    toc: yes
    toc_depth: 2
---
## Goal  
* This app designs for displaying transcription factor and gene data from mice in various fancy ways by three main tabs including:  
  - Given user's TF input, display a table of genes associated with that TF and a network graph visualization displaying detailed information with node color and edge thickness
  - A heatmap which visualizes color gradient using NES(the activity score) per cluster/cell (PS: might be interactive)
  - A scatterplot that, using UMAP cluster algorithm, reduces dimensions in huge cluster genetic data, display closely related clusters. 
  
More details of functions of each tab will be shown later, with major aspects: user input, output, datasets, libraries required and possible demos of plot/table


## To-do list and questions: 
make several updates of features:  
  - a text title of UMAP cluster, change 'binary activity' into 'proportion of ... tf'
### things need to learn: 
- Hackathon:  
  - plotly, complex heatmap
- problem:  
  - error of coercing... in ribbon plot  - run debugger automatically  
- Monday meeting:  
  - cell_metadata for timeseries plot? I don't seem to have that data  
  - show error of missing TFs?  
  - in psuedotime?  
  - ggplot sometimes show up on app html page but in plot console  
  - change default color of the scatterplot  
  - add explanation of the missing TF in activity_cell datasets  
  - analyze source code of rcytoscapejs2 to see if a graph input can be produced
  - maybe put more time in learning during hackathon  

- organize data  
  + name datasets with different prefix according to brain region  
  + import all datasets initially before ui and server function except big datasets, feather data  
  + put data in reactive if that involves input$TF and frequently needs to be updated
- Keep several layouts in one page  
- heatmap, complex heatmap  
- maybe learn dynamic UI  

### unsolved: 
- Problem: cell data might be too big that I can't plot heatmap?
- use a list to save all datasets? use event reactive ..
- heatmap plot, a good way to organize code? use function?

- Professor mentioned: static data... (contruct this in a big picture... design ability to switch 2 brain regions from the very beginning, and so on. Get a bunch of user input as a vector? then use that vector to do things accordingly and automatically, instead of hardcoding?) maybe this can apply to the theme(parameters of plot...) of the app, but what about other features?
  1. data  
  2. element for the data  
  3. **style** for that element ??
  4. theme elements??
- May 15: New ideas:
  1. User input can be:
    - empty -> we choose one to display initially
    - error (TF not found...) might not be a problem because we let user to select from a given active_TF vector
    - one TF (trivial case)
    - a list of TF (user can select multiple TF from either):
        - direct typing or 
        - **interacting with the graph nodes plot generated from Tab1(cola feature).**  
  2. Keep several layouts in one page  
  3. HEATMAP:  
    - display the **complex heatmap** using that package, that can **interact with user**  
    - Intially, display the heatmap for all the TF(each row is a TF), then user can select several TF to subset the graph
      + This input can also be *taken from the input list form step 1*  
  
  4. UMAP cluster scatterplot: 
    - change the color of dots using colorRampPalette
  
  5. Template (general)
    - **Format contents in different blocks** (instead of hardcoding each situation,
    **but not writing functions?**)
    - ex. A block of code that interacts with user input (TF vector) and

- why can NES have negative value?  
- group those clusters further? neuron.. epithelial...? in Tab2 cluster plot  

### solved: 
- What input do heatmap, scatterplot cluster base on?  - still TF
- display a small table of datasets for demonstration - success
- implementation of UMAP into code, any package? - no need for it, just two columns of forehead data  
- assign training sets to the corresponding tab/plot  
- Detailed definition of joint cortex? - have 5 time plots of pon and forebrain cluster data then join them again into a whole plot to see the overall relations and correlations of each cell

## Library
```{r, message= FALSE}
library(shiny)
library(tidyverse)
library(dplyr)
library(feather)
library(ggplot2)
library(pheatmap)
library(DT)
library(rcytoscapejs2)

load("data/joint_cortex/cortex_prep.Rda")
source("functions.R")

#library(pheatmap)

```

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
```

## Datasets
### 1. Metadata of cluster information
```{r,results='asis', message= FALSE}
metadata <- read_tsv("data/joint_cortex/metadata_20190716.tsv")
to_display <- select(metadata, -Signature)
knitr::kable(to_display[1:5,1:10], caption = "Table demo [1:5,1:10]")
```  

* with the important columns being:
  + Cluster (matching all the data)
  + Cell_type (the full name of the cell type)
  + Age (the time point of the sample)
  + Colour (a hex value to use as a colour for that cluster)

### 2. Forebrain data (Cortex)
```{r,results='asis', message= FALSE}
forebrain_data <- read_tsv("data/joint_cortex/Forebrain_join.2D.tsv")
knitr::kable(forebrain_data[1:5,], caption = "Table demo")
```

Contains cells from all mouse forebrain samples with joint cluster information and 2D PCA, tSNE and UMAP coordinates in joint space. Clustering/tSNE coordinates are as in Extended Data Figure 1e. The Cell column matches the other datasets, and the **two columns** to use to make scatter plots are **UMAP1 (x-axis) and UMAP2 (y-axis)**.

### 3. Active TF data
```{r,results='asis', message= FALSE}
TF_active <- read_rds("data/joint_cortex/joint_cortex.active_regulons.Rds") # a vector
knitr::kable(TF_active[1:10], caption = "Table demo")
```

Vector of transcription factors declared as active in the sample  
**Note:** will be cleaned by trimming the weights and extensions.  

### 4. TF's target gene data
```{r,results='asis', message= FALSE}
TF_target_gene <- read_rds("data/joint_cortex/joint_cortex.regulon_target_info.Rds")
knitr::kable(TF_target_gene[1:5,], caption = "Table demo")
```

Table indicating the targets ("gene") for each transcription factor ("TF"), and information about the target, including weight and activity

### Activity data (with respect to cell/cluster) 

#### 5. Activity per cluster
```{r,results='asis', message= FALSE}
activity_cluster <- read_feather("data/joint_cortex/joint_cortex.regulon_activity_per_cluster.feather")
knitr::kable(activity_cluster[1:5,1:5], caption = "Table demo")
```

A dataframe, the first column is cluster, subsequent columns correspond to active TF (TF_active) the values describe the NES(activity score of TF in each cluster)

#### 6. Activity per cell 
```{r,results='asis', message= FALSE}
activity_cell <- read_feather("data/joint_cortex/joint_cortex.regulon_activity_per_cell.feather")
knitr::kable(activity_cell[1:5,1:5], caption = "Table demo")
```

The first column changes to cell, we use this for the UMAP cluster scatterplot in tab2.


# Tabs
## 1. table and network
- discription: Given user's TF input, display a table of genes associated with that TF and a network graph visualization displaying detailed information with node color and edge thickness 
- data: 4. TF_target_gene; 5. Activity per cluster
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- **package**:  
```{r, message= FALSE}
library(shiny)
library(rcytoscapejs2)
TF <- c("Arx","Lef1")
```

```{r}
# an option to neglect greycolor nodes
unique_TF <- unique(TF_target_gene[["TF"]])
nodeData <- create_network(TF)$nodes#%>%
  #filter(color!="lightgrey")
#nodeData$height <- 50
#nodeData$width <- 50
edgeData <- create_network(TF)$edges 
#edgeData$color <- "#9d4097"

```

```{r}
network <- createCytoscapeJsNetwork(nodeData, edgeData)
rcytoscapejs2(network$nodes, network$edges)
```


## 2. Heatmap and cluster scatterplot
- discription: Given user's TF input, display a heatmap and clustering scatterplot
- **package**:  
```{r, message= FALSE}
library(shiny)
library(ggplot2)
library(pheatmap)
```
- data: 4.TF_target_gene, 5. Activity per cluster, 6. Activity per cell
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- output: 
  1. A heatmap that, given a specific TF, we filter the activity_cluster datasets with this TF then display a heatmap that shows the level of activity featured by NES(score). You will see a gradient of color which makes a great straightforwad visualization.  
  The x-axis correspond to each cluster.  
  
  
### Option 1: plot by Cluster
```{r}

colour_palette <- metadata %>% 
  # use gsub to change all contents in Cluster (cluster name format)
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe() # VECTOR , not data frame 

# A helper function to prepare a dataframe to annotate the heatmap with colours
hm_anno <- makePheatmapAnno(colour_palette, "Cluster")

act_cluster <- create_activity_data(c("E2f1","Atf3"), "Cluster") %>%
  sample_n(30) %>%
  tibble::column_to_rownames(var = "Cluster") # make that column name as row name ...

pheatmap::pheatmap(t(act_cluster),
                   #show_colnames = FALSE,
                   scale = "none",
                   border_color = NA,
                   color = colorRampPalette(c("blue", "white", "red"))(100),
                   main = "Plot by Clusters",
                   annotation_col = hm_anno$anno_row,
                   # change the default color annotation
                   annotation_colors = hm_anno$side_colors, 
                   annotation_legend = ,
                   cellwidth = 10,
                   cellheight = 10)
act_cluster
t(act_cluster)
hm_anno$anno_row
length(hm_anno$side_colors[[1]])
```
  ![alt text](data/image/heatmap_demo3.png)  
### Option 2: plot by Cell, no colour palette
```{r}
colour_palette <- metadata %>% 
  # use gsub to change all contents in Cluster (cluster name format)
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe() # VECTOR , not data frame 

palette <- colour_palette[unique(names(colour_palette))] # with unique names
  # Make dataframe, retrieve the data frame
anno_row <- data.frame(cluster = names(palette))
names(anno_row) <- "Cluster"  # just change the name ...
rownames(anno_row) <- anno_row[[1]]

head(palette)
head(anno_row)
```

```{r}
# Make list containing colours
side_colors <- list(cluster = palette)
names(side_colors) <- "Cluster" # just change the name ...

# A helper function to prepare a dataframe to annotate the heatmap with colours
hm_anno <- makePheatmapAnno(colour_palette, "Cluster")

head(side_colors)
```
### Pheatmap recap: how to make annotation_col or row  
```{r}
library(pheatmap)

# Create test matrix
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
# Generate annotations for rows and columns
annotation_col = data.frame(
                    CellType = factor(rep(c("CT1", "CT2"), 5)), 
                    Time = 1:5
                )
rownames(annotation_col) = paste("Test", 1:10, sep = "")

annotation_row = data.frame(
                    GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6)))
                )
rownames(annotation_row) = paste("Gene", 1:20, sep = "")

# Display row and color annotations
# Draw heatmaps
pheatmap(test)
# pheatmap(test, kmeans_k = 2)
# pheatmap(test, scale = "row", clustering_distance_rows = "correlation")
# pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
# pheatmap(test, cluster_row = FALSE)
# pheatmap(test, legend = FALSE)
pheatmap(test, annotation_col = annotation_col)
pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row)

# test
 annotation_col
# annotation_row
```

```{r}
#,"Atf3","Dlx1","Olig2","Lef1","Hes6",
act_cell <- create_activity_data(c("E2f1","Sox9"), "Cell") %>%
  mutate(Cluster = gsub("_"," ",forebrain_data[["Sample_cluster"]])) %>%
  filter(!grepl("BLACKLIST", Cluster)) %>%
   sample_n(300) %>%
  tibble::column_to_rownames(var = "Cell") # make that column name as row name ...
#factor <- factor(select(act_cell, Cluster))
anno_row_cell <- select(act_cell, Cluster)
#anno_row_cell$Cluster <- as.factor(anno_row_cell$Cluster)

act_cell <- select(act_cell, -Cluster)# %>% # must remove Cluster data before plotting
  #sample_n(30)

pheatmap::pheatmap(t(act_cell),
                   show_colnames = FALSE,
                   scale = "none",
                   border_color = NA,
                   color = colorRampPalette(c("blue", "white", "red"))(100),
                   main = "Plot by Cells",
                   annotation_col = anno_row_cell,
                   # change the default color annotation
                   annotation_colors = hm_anno$side_colors, 
                   annotation_legend = TRUE,
                   cellwidth = 2,
                   cellheight = 10)
# anno_row_cell
# act_cell
# hm_anno$side_colors
``` 
 
  
  2. A scatterplot that plots a scatter plot using UMAP1 and UMAP2 in forebrain_data, then given a user input of TF, using the 6. Activity per cell: activity_cell, change the color of each cell to reflect their TF activity, based on the user input of TF
  ![alt text](data/image/UMAP_demo1.png)  
```{r,results='asis', message= FALSE, echo = TRUE}
activity_test1 <- activity_cell[["E2f1 (122g)"]] # mutate need a vector

# add a activity column
forebrain_with_activity <- mutate(forebrain_data, activity_1 = activity_test1) 

ggplot(data = forebrain_with_activity, mapping = aes(x=UMAP1,y=UMAP2))+
  geom_point(aes(color = activity_1))+
  theme_bw()
```  


```{r,results='asis', message= FALSE, echo = TRUE}
activity_test2 <- activity_cell[[120]] # a very different TF
# add a activity column
forebrain_with_activity <- mutate(forebrain_data, activity_2 = activity_test2) 

ggplot(data = forebrain_with_activity, mapping = aes(x=UMAP1,y=UMAP2))+
  geom_point(aes(color = activity_2))+
  theme_bw()
 
```






## 3. Time series plot
- discription: Given user's TF input, plot a time series trajectory of TF activity in pseudotime.
- **package**:  
```{r, message= FALSE}
library(shiny)
library(ggplot2)
```
- data: 4.TF_target_gene, 5. Activity per cluster, 6. Activity per cell
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- output: A time series plot of TF activity in pseudotime
![alt text](data/image/timeseries_1.png)  
Here each dot corresponds to a cell and we can see the type from the colors.
However, in our plot, we are displaying TF activity so the y-axis should be TF activity instead of expression level.

## First, make color palette for plotting
```{r}

colour_palette <- metadata %>% 
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  separate(Cluster, into = c("Prefix", "Cluster"), sep = " ") %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  distinct(Cluster, .keep_all = TRUE) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe()
head(colour_palette)



```
load the cell metadata
```{r}
cell_metadata <- read_tsv("data/joint_cortex/joint_cortex.metadata.tsv") %>% 
  select(Age = orig.ident, Cell, Cluster = ID_20190730_with_blacklist_and_refined) %>% 
  # In this case, we remove the "prefix" of the Cluster column, so that we are
  # simply left with the abbreviation representing the cell type, so that 
  # we can link the cells of the same cell type across ages
  separate(Cluster, into = c("Prefix", "Cluster"), sep = "_") %>% 
  mutate(Age = factor(Age, levels = c("Forebrain E12.5",
                                      "Forebrain E15.5",
                                      "Forebrain P0",
                                      "Forebrain P3",
                                      "Forebrain P6"))) %>% 
  arrange(Cell)
head(cell_metadata)
```
Load the binary TF activity
```{r}

activity <- readRDS("data/joint_cortex/joint_cortex.binaryRegulonActivity_nonDupl.Rds")

activity[1:3, 1:3]

```
```{r}
# This step will change depending on the TF used
TF <- "Dlx1 (16g)" # input_tf

activity <- activity[TF, ] %>% 
  {data.frame("TF" = .)} %>% 
  tibble::rownames_to_column(var = "Cell") %>% # the original activity vector has names
  arrange(Cell)

```

Prep a tidy data frame:

```{r}

# Double check all Cell names are the same / in same order
all(cell_metadata$Cell == activity$Cell)

# Add the TF activity to the new dataframe
ribbon_df <- cell_metadata
ribbon_df$TF <- activity$TF

ribbon_df <- ribbon_df %>% 
  filter(!grepl("BLACKLIST", Cluster))

head(cell_metadata)

```

Make the plot:

```{r, fig.width = 10, fig.height = 8}

# Calculate for each cell type, the proportion of cells where the 
# TF is active
ribbon_df_celltype_frac <- ribbon_df %>% 
  group_by(Age) %>% 
  # Total cells at each age
  mutate(total = n()) %>% 
  group_by(Age, Cluster) %>%
  # Proportion of TF+ cells per cluster, per age
  mutate(frac = sum(TF > 0) / total) %>% 
  distinct(Age, Cluster, frac) %>% 
  ungroup()

ribbon_df_cum_frac <- ribbon_df %>% 
  group_by(Age) %>% 
  summarize(cumfrac = sum(TF > 0) / n()) %>% 
  ungroup()

timepoints2 <- ribbon_df$Age
clusters <- ribbon_df$Cluster

df = data.frame(cluster = rep(unique(clusters), length(unique(timepoints2))),
                stage = do.call(c, lapply(as.character(unique(timepoints2)), rep, times = length(unique(clusters)))))

df$ranking = match(df$cluster, names(colours))
df = df[order(df$stage, df$ranking),]

df <- left_join(df, select(ribbon_df_celltype_frac, cluster = Cluster, stage = Age, frac)) %>% 
  mutate(frac = replace_na(frac, 0)) %>% 
  left_join(select(ribbon_df_cum_frac, stage = Age, cumfrac))

df$xpos = match(df$stage, unique(timepoints2))

df %>%
  ggplot(aes(x = xpos, y = frac, fill = cluster)) +
  geom_area(stat = "identity") +
  scale_fill_manual(values = colour_palette, drop = FALSE, name = "") +
  scale_x_continuous(breaks = seq_along(unique(df$stage)),
                     labels = c("E12.5", "E15.5", "P0", "P3", "P6"),
                     limits = c(1, length(unique(df$stage)))) +
  labs(x = "age", y = "Binary activity", title = TF) +
  guides(fill = guide_legend(ncol = 5)) +
  theme(legend.position = "bottom")

```
Plot by **pseudotime**: cells that captured at same time will vary vastly in their stage in development progress. To avoid this problem, rather than ploting the changes according to the age, we plot as a function of progress with respect to each cell along its own trajectory, which we term "pseudotime".







