---
title: "Description of joint cortex app"
author: "Anthony Ma"
date: "13/05/2020"
output:
  html_document:
    toc: yes
    toc_depth: 2
---
## Goal  
* This app designs for displaying transcription factor and gene data from mice in various fancy ways by three main tabs including:  
  - Given user's TF input, display a table of genes associated with that TF and a network graph visualization displaying detailed information with node color and edge thickness
  - A heatmap which visualizes color gradient using NES (the activity score) per cluster/cell (PS: might be interactive using complex heatmap)
  - A scatterplot that, using UMAP cluster algorithm, reduces dimensions in huge cluster genetic data, display closely related clusters. 
  
More details of functions of each tab will be shown later, with major aspects: user input, output, datasets, libraries required and possible demos of plot/table

## Second phase after prototype:  
Main modifications:
- organize data: combine pons and cortex datasets together, they have the same format for all data, choose the data structure to save them and assign in app.R using list  
  + update: make names in the list informative  
- add options of plotting by cell or cluster in the second tab, add color palette designed/commonly recognized in Kleinman lab  
- write new functions and add new parameters in order to reconcile the demand of easier coding, better readability and switch between two brain region datasets  

Further issue/modification required:  
- github branch setup, delete app.R?
- apply plotly on timeseries plot, see the cell types and how many cells are at the timepoints  
- some missing data of tf in each tabs, shall I change the input vector or give the lists of tfs that don't exist in a particular tab, or 
- analyze by pathways... done  
- install packages on server    
- add controls for the size of heatmaps... (width, height ...) -> maybe see complex heatmap if it has better control options interactively  
- heatmap, show a picture of the cluster color palette  
- tab1: display an additional table for the graph network  
- Modify tab3 function to suit the pons data  -- done  
- - plotly, complex heatmap features to be applied in this app, what features are good to be added?  
- support multiple plots of scatterplot in tab2 also add a title name by the tf  
- error message? Use a function? Any example online?  
  + show error of missing TFs?   
  + in psuedotime?  
  + add explanation of the missing TF in activity_cell datasets  
- consider some customization features (CSS...) since we've had a good prototype that supports basic functionality  
- get a taste of some real research activities, maybe using what I developed...feasibility and the process...ask prof and Selin  

Issue July 4: --  solved  
```
# cell_metadata_cortex_test is made using forebrain_data, cell_metadata_cortex is made using the new datasets
# F-p0 INIP, the space between the datasets cause the wrong performance when separating using the '_' delimitor

# metadata specific for each cell, corresponding to the activity data
forebrain_data <- read_tsv("data/joint_cortex/Forebrain_join.2D.tsv") %>%
  mutate(Sample_cluster = str_replace(Sample_cluster," ","_"))

cell_metadata_cortex_test <- create_metadata_timeseries(forebrain_data, "cortex")

cell_metadata_cortex_prep <- read_tsv("data/joint_cortex/joint_cortex.metadata.tsv")
cell_metadata_cortex <- create_cell_metadata(cell_metadata_cortex_prep)

setdiff(cell_metadata_cortex_test, cell_metadata_cortex)
filter(cell_metadata_cortex_test, is.na(Cluster)) # has 534 NA value
filter(cell_metadata_cortex, is.na(Cluster)) # has no NA value, better datasets...
```
## To-do list and questions: 

### things need to learn: 
- Hackathon:  
  - plotly, complex heatmap
- Monday meeting:  
  - show error of missing TFs?  
  - in psuedotime?  
  - add explanation of the missing TF in activity_cell datasets  
  
- organize data  
  + name datasets with different prefix according to brain region  
  + import all datasets initially before ui and server function except big datasets, feather data  
  + put data in reactive if that involves input$TF and frequently needs to be updated


### unsolved: 
- use a list to save all datasets? use event reactive ..
- heatmap plot, a good way to organize code? use function?

- Professor mentioned: static data... (contruct this in a big picture... design ability to switch 2 brain regions from the very beginning, and so on. Get a bunch of user input as a vector? then use that vector to do things accordingly and automatically, instead of hardcoding?) maybe this can apply to the theme(parameters of plot...) of the app, but what about other features?
  1. data  
  2. element for the data  
  3. **style** for that element ??
  4. theme elements??
- May 15: New ideas:
  1. User input can be:
    - empty -> we choose one to display initially
    - error (TF not found...) might not be a problem because we let user to select from a given active_TF vector
    - one TF (trivial case)
    - a list of TF (user can select multiple TF from either):
        - direct typing or 
        - **interacting with the graph nodes plot generated from Tab1(cola feature).**  
  2. Keep several layouts in one page  
  3. HEATMAP:  
    - display the **complex heatmap** using that package, that can **interact with user**  
    - Intially, display the heatmap for all the TF(each row is a TF), then user can select several TF to subset the graph
      + This input can also be *taken from the input list form step 1*  
  
  4. UMAP cluster scatterplot: 
    - change the color of dots using colorRampPalette
  
  5. Template (general)
    - **Format contents in different blocks** (instead of hardcoding each situation,
    **but not writing functions?**)
    - ex. A block of code that interacts with user input (TF vector) and

- why can NES have negative value?  
- group those clusters further? neuron.. epithelial...? in Tab2 cluster plot  

### solved: 
- What input do heatmap, scatterplot cluster base on?  - still TF
- display a small table of datasets for demonstration - success
- implementation of UMAP into code, any package? - no need for it, just two columns of forehead data  
- assign training sets to the corresponding tab/plot  
- Detailed definition of joint cortex? - have 5 time plots of pon and forebrain cluster data then join them again into a whole plot to see the relations and correlations of each cell

## Library, remember to install rcytoscapejs2 from github first
```{r, message= FALSE}
library(rcytoscapejs2) # need to install from github

library(shiny)
library(tidyverse)
library(dplyr)
library(feather)
library(ggplot2)
library(pheatmap)
library(DT)
library(glue)

load("data/joint_cortex/cortex_prep.Rda") # a list, data_cortex
load("data/joint_pons/pons_prep.Rda")     # a list, data_pons
load("data/joint_cortex/common_prep.Rda") # metadata and colour_palettes
source("functions.R")



```

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
```

## Datasets
### 1. Metadata of cluster information
```{r,results='asis', message= FALSE}
metadata <- read_tsv("data/joint_cortex/metadata_20190716.tsv")
to_display <- select(metadata, -Signature)
knitr::kable(to_display[1:5,1:10], caption = "Table demo [1:5,1:10]")
```  

* with the important columns being:
  + Cluster (matching all the data)
  + Cell_type (the full name of the cell type)
  + Age (the time point of the sample)
  + Colour (a hex value to use as a colour for that cluster)

### 2. Forebrain data (Cortex)
```{r,results='asis', message= FALSE}
forebrain_data <- read_tsv("data/joint_cortex/Forebrain_join.2D.tsv")
knitr::kable(forebrain_data[1:5,], caption = "Table demo")
```

Contains cells from all mouse forebrain samples with joint cluster information and 2D PCA, tSNE and UMAP coordinates in joint space. Clustering/tSNE coordinates are as in Extended Data Figure 1e. The Cell column matches the other datasets, and the **two columns** to use to make scatter plots are **UMAP1 (x-axis) and UMAP2 (y-axis)**.

### 3. Active TF data
```{r,results='asis', message= FALSE}
TF_active <- read_rds("data/joint_cortex/joint_cortex.active_regulons.Rds") # a vector
knitr::kable(TF_active[1:10], caption = "Table demo")
```

Vector of transcription factors declared as active in the sample  
**Note:** will be cleaned by trimming the weights and extensions.  

### 4. TF's target gene data
```{r,results='asis', message= FALSE}
TF_target_gene_info <- read_rds("data/joint_cortex/joint_cortex.regulon_target_info.Rds")
knitr::kable(TF_target_gene_info[1:5,], caption = "Table demo")
```

Table indicating the targets ("gene") for each transcription factor ("TF"), and information about the target, including weight and activity

### Activity data (with respect to cell/cluster) 

#### 5. Activity per cluster
```{r,results='asis', message= FALSE}
activity_cluster <- read_feather("data/joint_cortex/joint_cortex.regulon_activity_per_cluster.feather")
knitr::kable(activity_cluster[1:5,1:5], caption = "Table demo")
```

A dataframe, the first column is cluster, subsequent columns correspond to active TF (TF_active) the values describe the NES(activity score of TF in each cluster)

#### 6. Activity per cell 
```{r,results='asis', message= FALSE}
activity_cell <- read_feather("data/joint_cortex/joint_cortex.regulon_activity_per_cell.feather")
knitr::kable(activity_cell[1:5,1:5], caption = "Table demo")
```

The first column changes to cell, we use this for the UMAP cluster scatterplot in tab2.


# Tabs
## Tab1. table and network
- discription: Given user's TF input, display a table of genes associated with that TF and a network graph visualization displaying detailed information with node color and edge thickness 
- data: 4. TF_target_gene_info; 5. Activity per cluster
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- **package**:  
```
library(shiny)
library(DT)
library(rcytoscapejs2)
```
```{r}
input_tf <- c("Lhx5","Pax7")
datatable(dplyr::filter(data_pons$TF_target_gene_info, TF %in% input_tf))

```

```{r}
TF <- c("Lhx5","Pax7")
tf_pathway <- c("Gad2")

nodeData <- create_network(TF, data_pons$TF_target_gene_info, data_pons$unique_active_TFs_bare, tf_pathway)$nodes
edgeData <- create_network(TF, data_pons$TF_target_gene_info, data_pons$unique_active_TFs_bare, tf_pathway)$edges
network <- createCytoscapeJsNetwork(nodeData, edgeData)
rcytoscapejs2(network$nodes, network$edges)

```


## 2. Heatmap and cluster scatterplot
- discription: Given user's TF input, display a heatmap and clustering scatterplot
- **package**:  
```
library(shiny)
library(ggplot2)
library(pheatmap)
```
- data: 4.TF_target_gene_info, 5. Activity per cluster, 6. Activity per cell
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- output: 
  1. A heatmap that, given a specific TF, we filter the activity_cluster datasets with this TF then display a heatmap that shows the level of activity featured by NES(score). You will see a gradient of color which makes a great straightforwad visualization.  
  The x-axis correspond to each cluster.  
  
  
### Option 1: plot by Cluster, Note that later in the app we will use function plot_heatmap() for easier control between regions and methods(by cell or cluster)
```{r}
colour_palette <- metadata %>% 
  # use gsub to change all contents in Cluster (cluster name format)
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe() # VECTOR , not data frame 

# A helper function to prepare a dataframe to annotate the heatmap with colours
hm_anno <- makePheatmapAnno(colour_palette, "Cluster")

act_cluster <- create_activity_data(c("E2f1","Atf3"), "Cluster", "cortex",data_cortex$TF_and_ext) %>%
  sample_n(30) %>%
  tibble::column_to_rownames(var = "Cluster") # make that column name as row name ...

pheatmap::pheatmap(t(act_cluster),
                   #show_colnames = FALSE,
                   scale = "none",
                   border_color = NA,
                   color = colorRampPalette(c("blue", "white", "red"))(100),
                   main = "Plot by Clusters",
                   annotation_col = hm_anno$anno_row,
                   # change the default color annotation
                   annotation_colors = hm_anno$side_colors, 
                   annotation_legend = ,
                   cellwidth = 10,
                   cellheight = 10)

```

### Option 2: plot by Cell, same colour palette as plotting by cluster
```{r}
#,"Atf3","Dlx1","Olig2","Lef1","Hes6",
act_cell <- create_activity_data(c("E2f1","Sox9"), "Cell","cortex", data_cortex$TF_and_ext) %>%
  mutate(Cluster = gsub("_"," ",data_cortex$cell_metadata[["Sample_cluster"]])) %>%
  filter(!grepl("BLACKLIST", Cluster)) %>%
   sample_n(300) %>%
  tibble::column_to_rownames(var = "Cell") # make that column name as row name ...

anno_row_cell <- select(act_cell, Cluster)

act_cell <- select(act_cell, -Cluster)# %>% # must remove Cluster data before plotting
  #sample_n(30)

pheatmap::pheatmap(t(act_cell),
                   show_colnames = FALSE,
                   scale = "none",
                   border_color = NA,
                   color = colorRampPalette(c("blue", "white", "red"))(100),
                   main = "Plot by Cells",
                   annotation_col = anno_row_cell,
                   # change the default color annotation
                   annotation_colors = hm_anno$side_colors, 
                   annotation_legend = TRUE,
                   cellwidth = 2,
                   cellheight = 10)

``` 

### Pheatmap recap: how to make annotation_col or row  
```{r}
library(pheatmap)

# Create test matrix
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
# Generate annotations for rows and columns
annotation_col = data.frame(
                    CellType = factor(rep(c("CT1", "CT2"), 5)), 
                    Time = 1:5
                )
rownames(annotation_col) = paste("Test", 1:10, sep = "")

annotation_row = data.frame(
                    GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6)))
                )
rownames(annotation_row) = paste("Gene", 1:20, sep = "")

# Display row and color annotations
# Draw heatmaps
pheatmap(test)
# pheatmap(test, kmeans_k = 2)
# pheatmap(test, scale = "row", clustering_distance_rows = "correlation")
# pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
# pheatmap(test, cluster_row = FALSE)
# pheatmap(test, legend = FALSE)
pheatmap(test, annotation_col = annotation_col)
pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row)

# test
 annotation_col
# annotation_row
```


 
  2. A scatterplot that plots a scatter plot using UMAP1 and UMAP2 in forebrain_data, then given a user input of TF, using the 6. Activity per cell: activity_cell, change the color of each cell to reflect their TF activity, based on the user input of TF
  ![alt text](data/image/UMAP_demo1.png)  
```{r,results='asis', message= FALSE, echo = TRUE}
# the first col is Cell [,1][1], so we use [2,1][1] for the first tf in the tf vector

tf <- c("Arx","Lef1","Dlx1")
activity_test_tf1 <- create_activity_data(tf, "Cell","cortex", data_cortex$TF_and_ext)
activity_test_tf1[,4]
ncol(activity_test_tf1)

plot_UMAP(tf_number = 2,data_cortex$cell_metadata, activity_test_tf1)





```  
```{r}
df_1 <- data.frame(x=c(5, 6, 7, 8, 9), y = c(200, 225, 250, 270, 310))

options(repr.plot.width = 1, repr.plot.height = 0.75)
ggplot(df_1, aes(x = x, y = y)) + geom_point(size = 0.3) + 
   theme(text = element_text(size = 3), element_line(size = 0.1))

```

```{r}

df_1 = data.frame(x=c(5, 6, 7, 8, 9), y = c(200, 225, 250, 270, 310))

options(repr.plot.width = 4, repr.plot.height = 3)
ggplot(df_1, aes(x = x, y = y)) + geom_point(size = 0.3) + 
  theme(text = element_text(size = 12), element_line(size = 0.4))

```


```{r,results='asis', message= FALSE, echo = TRUE}
TF <- c("Lef1", "Arx", "Dlx1")
activity_test_pon <- create_activity_data(TF, "Cell","pons", data_pons$TF_and_ext)

activity_test_pon[,2]
p <- plot_UMAP(tf_number = 1,data_pons$cell_metadata, activity_test_pon)
ggplotly(p)
 activity_test_pon
```




## 3. Time series plot
- discription: Given user's TF input, plot a time series trajectory of TF activity in pseudotime.
- **package**:  
```{r, message= FALSE}
library(shiny)
library(ggplot2)
```
- data: 4.TF_target_gene_info, 5. Activity per cluster, 6. Activity per cell
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- output: A time series plot of TF activity in pseudotime
![alt text](data/image/timeseries_1.png)  
Here each dot corresponds to a cell and we can see the type from the colors.
However, in our plot, we are displaying TF activity so the y-axis should be TF activity instead of expression level.

## First, make color palette for plotting
```{r}

colour_palette <- metadata %>% 
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  separate(Cluster, into = c("Prefix", "Cluster"), sep = " ") %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  distinct(Cluster, .keep_all = TRUE) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe()
head(colour_palette)



```
load the cell metadata
```{r}
cell_metadata <- read_tsv("data/joint_cortex/joint_cortex.metadata.tsv") %>% 
  select(Age = orig.ident, Cell, Cluster = ID_20190730_with_blacklist_and_refined) %>% 
  # In this case, we remove the "prefix" of the Cluster column, so that we are
  # simply left with the abbreviation representing the cell type, so that 
  # we can link the cells of the same cell type across ages
  separate(Cluster, into = c("Prefix", "Cluster"), sep = "_") %>% 
  mutate(Age = factor(Age, levels = c("Forebrain E12.5",
                                      "Forebrain E15.5",
                                      "Forebrain P0",
                                      "Forebrain P3",
                                      "Forebrain P6"))) %>% 
  arrange(Cell)
head(cell_metadata)
```
Load the binary TF activity
```{r}

activity <- readRDS("data/joint_cortex/joint_cortex.binaryRegulonActivity_nonDupl.Rds")

activity[1:3, 1:3]

```
```{r}
# This step will change depending on the TF used
TF <- "Dlx1 (16g)" # input_tf

activity <- activity[TF, ] %>% 
  {data.frame("TF" = .)} %>% 
  tibble::rownames_to_column(var = "Cell") %>% # the original activity vector has names
  arrange(Cell)

```

Prep a tidy data frame:

```{r}

# Double check all Cell names are the same / in same order
all(cell_metadata$Cell == activity$Cell)

# Add the TF activity to the new dataframe
ribbon_df <- cell_metadata
ribbon_df$TF <- activity$TF

ribbon_df <- ribbon_df %>% 
  filter(!grepl("BLACKLIST", Cluster))

head(cell_metadata)

```

Make the plot:

```{r, fig.width = 10, fig.height = 8}
tf_df <- as_tibble(rownames(data_cortex$binary_activity))
TF <- translate_tf("Lef1",tf_df)
binary_activity <- data_cortex$binary_activity
# cell_metadata_cortex <- read_tsv("data/joint_cortex/joint_cortex.metadata.tsv")
# cell_metadata_cortex <- create_cell_metadata(cell_metadata_cortex)
ggplotly(plot_timeseries(TF,data_cortex$timeseries_input_meta, data_cortex$binary_activity))

activity <- data_pons$binary_activity

# # must remove the extra cell
# timeseries_input_meta_pons <- create_metadata_timeseries(data_pons$cell_metadata,"pons") %>%
#   filter(Cell != "___po_e12_TACGGGCGTCAAGCGA")
# 
# setdiff(cell_metadata_pon,timeseries_input_meta_pons)

TF <- translate_tf("Pax6",data_pons$binary_active_TFs)

p <- plot_timeseries(TF, data_pons$timeseries_input_meta, data_pons$binary_activity)
library(plotly)
ggplotly(p)
translate_tf(rownames(data_pons$binary_activity), data_pons$binary_active_TFs)
rownames(data_pons$binary_activity)

data_pons$binary_active_TFs
tf_converted <- translate_tf(data_pons$unique_active_TFs_bare,data_pons$binary_active_TFs)

 
```
```{r}
l <- c()
l_nexist <- c()

for (tf in data_pons$unique_active_TFs_bare){
 tf_after <- translate_tf(tf,data_pons$binary_active_TFs)
  if(tf_after !=FALSE ){
    l <- c(l, tf)
  }
 else{l_nexist<- c(l_nexist,tf)}
}
l # unique_active_TFs_bare after converting the type in pons data
l_nexist # tfs not exist in the binary_active datasets
length(data_pons$unique_active_TFs_bare) # without types
length(data_pons$binary_active_TFs[[1]]) # with types, 86
length(l) # 86, same as 

tf_input <- c("Cbfb", "Creb3", "Creb5")
tf_nexist <- ""
for(tf in tf_input){
    if (tf %in% l_nexist){
      tf_nexist <- paste(tf_nexist,tf,sep = " ")
    }
}
tf_nexist
glue('Those tfs does not not exist in our datasets: {tf_nexist}')

if(tf_nexist == ""){
  
}

```


install SIN
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::version()
# If your bioconductor version is previous to 3.9, see the section bellow

BiocManager::install(c("AUCell", "RcisTarget"))
BiocManager::install(c("GENIE3")) # Optional
# Also required:
install.packages('zoo')

# Recommended to run AUCell:
BiocManager::install(c("mixtools", "rbokeh"))
# For various visualizations and perform t-SNEs:
BiocManager::install(c("DT", "NMF", "pheatmap", "R2HTML", "Rtsne"))
# To support paralell execution (not available in Windows):
BiocManager::install(c("doMC", "doRNG"))
# To export/visualize in http://scope.aertslab.org
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
devtools::install_github("aertslab/SCopeLoomR", build_vignettes = TRUE)

# regulons <- loadInt(scenicOptions, "regulons")
# regulons[c("Dlx5", "Irf1")]
packageVersion("AUCell")
packageVersion("RcisTarget")
packageVersion("GENIE3")
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")

devtools::install_github("aertslab/SCENIC", ref="v1.1.1") # To specify a version: ref="v1.1.0"
packageVersion("SCENIC")


```
Plot by **pseudotime**: cells that captured at same time will vary vastly in their stage in development progress. To avoid this problem, rather than ploting the changes according to the age, we plot as a function of progress with respect to each cell along its own trajectory, which we term "pseudotime".







