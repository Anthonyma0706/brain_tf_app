---
title: "Description of joint cortex app"
author: "Anthony Ma"
date: "13/05/2020"
output:
  html_document:
    toc: yes
    toc_depth: 2
---
## Goal  
* This app designs for displaying transcription factor and gene data from mice in various fancy ways by three main tabs including:  
  - Given user's TF input, display a table of genes associated with that TF and a network graph visualization displaying detailed information with node color and edge thickness
  - A heatmap which visualizes color gradient using NES (the activity score) per cluster/cell (PS: might be interactive using complex heatmap)
  - A scatterplot that, using UMAP cluster algorithm, reduces dimensions in huge cluster genetic data, display closely related clusters. 
  
More details of functions of each tab will be shown later, with major aspects: user input, output, datasets, libraries required and possible demos of plot/table

## Second phase after prototype:  
Main modifications:
- combine pons and cortex datasets together, they have the same format for all data, choose the data structure to save them and assign in app.R using list  
- add options of plotting by cell or cluster in the second tab, add color palette designed/commonly recognized in Kleinman lab  
- write new functions and add new parameters in order to reconcile the demand of easier coding, better readability and switch between two brain region datasets
- 

Further issue/modification required:  
- tab1: display an additional table for the graph network  
- Modify tab3 function to suit the pons data
- modify R markdown file to add the paramters of functions since we've changed the function parameters
- - plotly, complex heatmap features to be applied in this app  
- support multiple plots of scatterplot in tab2 also add a title name by the tf
- error message? Use a function? Any example online?
  + show error of missing TFs?  
  + in psuedotime?  
  + add explanation of the missing TF in activity_cell datasets  
- consider some customization features (CSS...) since we've had a good prototype that supports basic functionality  



## To-do list and questions: 

### things need to learn: 
- Hackathon:  
  - plotly, complex heatmap
- Monday meeting:  
  - show error of missing TFs?  
  - in psuedotime?  
  - add explanation of the missing TF in activity_cell datasets  
  
- organize data  
  + name datasets with different prefix according to brain region  
  + import all datasets initially before ui and server function except big datasets, feather data  
  + put data in reactive if that involves input$TF and frequently needs to be updated


### unsolved: 
- use a list to save all datasets? use event reactive ..
- heatmap plot, a good way to organize code? use function?

- Professor mentioned: static data... (contruct this in a big picture... design ability to switch 2 brain regions from the very beginning, and so on. Get a bunch of user input as a vector? then use that vector to do things accordingly and automatically, instead of hardcoding?) maybe this can apply to the theme(parameters of plot...) of the app, but what about other features?
  1. data  
  2. element for the data  
  3. **style** for that element ??
  4. theme elements??
- May 15: New ideas:
  1. User input can be:
    - empty -> we choose one to display initially
    - error (TF not found...) might not be a problem because we let user to select from a given active_TF vector
    - one TF (trivial case)
    - a list of TF (user can select multiple TF from either):
        - direct typing or 
        - **interacting with the graph nodes plot generated from Tab1(cola feature).**  
  2. Keep several layouts in one page  
  3. HEATMAP:  
    - display the **complex heatmap** using that package, that can **interact with user**  
    - Intially, display the heatmap for all the TF(each row is a TF), then user can select several TF to subset the graph
      + This input can also be *taken from the input list form step 1*  
  
  4. UMAP cluster scatterplot: 
    - change the color of dots using colorRampPalette
  
  5. Template (general)
    - **Format contents in different blocks** (instead of hardcoding each situation,
    **but not writing functions?**)
    - ex. A block of code that interacts with user input (TF vector) and

- why can NES have negative value?  
- group those clusters further? neuron.. epithelial...? in Tab2 cluster plot  

### solved: 
- What input do heatmap, scatterplot cluster base on?  - still TF
- display a small table of datasets for demonstration - success
- implementation of UMAP into code, any package? - no need for it, just two columns of forehead data  
- assign training sets to the corresponding tab/plot  
- Detailed definition of joint cortex? - have 5 time plots of pon and forebrain cluster data then join them again into a whole plot to see the overall relations and correlations of each cell

## Library
```{r, message= FALSE}
library(shiny)
library(tidyverse)
library(dplyr)
library(feather)
library(ggplot2)
library(pheatmap)
library(DT)
library(rcytoscapejs2)
library(glue)
load("data/joint_cortex/cortex_prep.Rda") # a list, data_cortex
load("data/joint_pons/pons_prep.Rda")     # a list, data_pons
load("data/joint_cortex/common_prep.Rda") # metadata and colour_palettes
source("functions.R")

#library(pheatmap)

```

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
```

## Datasets
### 1. Metadata of cluster information
```{r,results='asis', message= FALSE}
metadata <- read_tsv("data/joint_cortex/metadata_20190716.tsv")
to_display <- select(metadata, -Signature)
knitr::kable(to_display[1:5,1:10], caption = "Table demo [1:5,1:10]")
```  

* with the important columns being:
  + Cluster (matching all the data)
  + Cell_type (the full name of the cell type)
  + Age (the time point of the sample)
  + Colour (a hex value to use as a colour for that cluster)

### 2. Forebrain data (Cortex)
```{r,results='asis', message= FALSE}
forebrain_data <- read_tsv("data/joint_cortex/Forebrain_join.2D.tsv")
knitr::kable(forebrain_data[1:5,], caption = "Table demo")
```

Contains cells from all mouse forebrain samples with joint cluster information and 2D PCA, tSNE and UMAP coordinates in joint space. Clustering/tSNE coordinates are as in Extended Data Figure 1e. The Cell column matches the other datasets, and the **two columns** to use to make scatter plots are **UMAP1 (x-axis) and UMAP2 (y-axis)**.

### 3. Active TF data
```{r,results='asis', message= FALSE}
TF_active <- read_rds("data/joint_cortex/joint_cortex.active_regulons.Rds") # a vector
knitr::kable(TF_active[1:10], caption = "Table demo")
```

Vector of transcription factors declared as active in the sample  
**Note:** will be cleaned by trimming the weights and extensions.  

### 4. TF's target gene data
```{r,results='asis', message= FALSE}
TF_target_gene <- read_rds("data/joint_cortex/joint_cortex.regulon_target_info.Rds")
knitr::kable(TF_target_gene[1:5,], caption = "Table demo")
```

Table indicating the targets ("gene") for each transcription factor ("TF"), and information about the target, including weight and activity

### Activity data (with respect to cell/cluster) 

#### 5. Activity per cluster
```{r,results='asis', message= FALSE}
activity_cluster <- read_feather("data/joint_cortex/joint_cortex.regulon_activity_per_cluster.feather")
knitr::kable(activity_cluster[1:5,1:5], caption = "Table demo")
```

A dataframe, the first column is cluster, subsequent columns correspond to active TF (TF_active) the values describe the NES(activity score of TF in each cluster)

#### 6. Activity per cell 
```{r,results='asis', message= FALSE}
activity_cell <- read_feather("data/joint_cortex/joint_cortex.regulon_activity_per_cell.feather")
knitr::kable(activity_cell[1:5,1:5], caption = "Table demo")
```

The first column changes to cell, we use this for the UMAP cluster scatterplot in tab2.


# Tabs
## 1. table and network
- discription: Given user's TF input, display a table of genes associated with that TF and a network graph visualization displaying detailed information with node color and edge thickness 
- data: 4. TF_target_gene; 5. Activity per cluster
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- **package**:  
```{r, message= FALSE}
library(shiny)
library(rcytoscapejs2)
TF <- c("Arx","Lef1")
```


```{r}
TF <- c("Lhx5","Pax7")
nodeData <- create_network(TF, data_pons$TF_target_gene, data_pons$unique_TF)$nodes
edgeData <- create_network(TF, data_pons$TF_target_gene, data_pons$unique_TF)$edges
network <- createCytoscapeJsNetwork(nodeData, edgeData)
rcytoscapejs2(network$nodes, network$edges)

```

## 2. Heatmap and cluster scatterplot
- discription: Given user's TF input, display a heatmap and clustering scatterplot
- **package**:  
```{r, message= FALSE}
library(shiny)
library(ggplot2)
library(pheatmap)
```
- data: 4.TF_target_gene, 5. Activity per cluster, 6. Activity per cell
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- output: 
  1. A heatmap that, given a specific TF, we filter the activity_cluster datasets with this TF then display a heatmap that shows the level of activity featured by NES(score). You will see a gradient of color which makes a great straightforwad visualization.  
  The x-axis correspond to each cluster.  
  
  
### Option 1: plot by Cluster
```{r}
colour_palette <- metadata %>% 
  # use gsub to change all contents in Cluster (cluster name format)
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe() # VECTOR , not data frame 

# A helper function to prepare a dataframe to annotate the heatmap with colours
hm_anno <- makePheatmapAnno(colour_palette, "Cluster")

act_cluster <- create_activity_data(c("E2f1","Atf3"), "Cluster", "cortex",data_cortex$TF_and_ext) %>%
  sample_n(30) %>%
  tibble::column_to_rownames(var = "Cluster") # make that column name as row name ...

pheatmap::pheatmap(t(act_cluster),
                   #show_colnames = FALSE,
                   scale = "none",
                   border_color = NA,
                   color = colorRampPalette(c("blue", "white", "red"))(100),
                   main = "Plot by Clusters",
                   annotation_col = hm_anno$anno_row,
                   # change the default color annotation
                   annotation_colors = hm_anno$side_colors, 
                   annotation_legend = ,
                   cellwidth = 10,
                   cellheight = 10)

```

### Option 2: plot by Cell, same colour palette as plotting by cluster
```{r}
#,"Atf3","Dlx1","Olig2","Lef1","Hes6",
act_cell <- create_activity_data(c("E2f1","Sox9"), "Cell","cortex", data_cortex$TF_and_ext) %>%
  mutate(Cluster = gsub("_"," ",data_cortex$overall[["Sample_cluster"]])) %>%
  filter(!grepl("BLACKLIST", Cluster)) %>%
   sample_n(300) %>%
  tibble::column_to_rownames(var = "Cell") # make that column name as row name ...

anno_row_cell <- select(act_cell, Cluster)

act_cell <- select(act_cell, -Cluster)# %>% # must remove Cluster data before plotting
  #sample_n(30)

pheatmap::pheatmap(t(act_cell),
                   show_colnames = FALSE,
                   scale = "none",
                   border_color = NA,
                   color = colorRampPalette(c("blue", "white", "red"))(100),
                   main = "Plot by Cells",
                   annotation_col = anno_row_cell,
                   # change the default color annotation
                   annotation_colors = hm_anno$side_colors, 
                   annotation_legend = TRUE,
                   cellwidth = 2,
                   cellheight = 10)

``` 

### Pheatmap recap: how to make annotation_col or row  
```{r}
library(pheatmap)

# Create test matrix
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
# Generate annotations for rows and columns
annotation_col = data.frame(
                    CellType = factor(rep(c("CT1", "CT2"), 5)), 
                    Time = 1:5
                )
rownames(annotation_col) = paste("Test", 1:10, sep = "")

annotation_row = data.frame(
                    GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6)))
                )
rownames(annotation_row) = paste("Gene", 1:20, sep = "")

# Display row and color annotations
# Draw heatmaps
pheatmap(test)
# pheatmap(test, kmeans_k = 2)
# pheatmap(test, scale = "row", clustering_distance_rows = "correlation")
# pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
# pheatmap(test, cluster_row = FALSE)
# pheatmap(test, legend = FALSE)
pheatmap(test, annotation_col = annotation_col)
pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row)

# test
 annotation_col
# annotation_row
```


 
  2. A scatterplot that plots a scatter plot using UMAP1 and UMAP2 in forebrain_data, then given a user input of TF, using the 6. Activity per cell: activity_cell, change the color of each cell to reflect their TF activity, based on the user input of TF
  ![alt text](data/image/UMAP_demo1.png)  
```{r,results='asis', message= FALSE, echo = TRUE}
activity_test1 <- create_activity_data("Arx", "Cell","cortex", data_cortex$TF_and_ext)[,2][[1]]
    
# add a activity column
forebrain_with_activity <- mutate(data_cortex$overall, activity_1 = activity_test1) 

ggplot(data = forebrain_with_activity, mapping = aes(x=UMAP1,y=UMAP2))+
        geom_point(aes(color = activity_1))+
        scale_color_gradientn(colors = rev(grDevices::colorRampPalette(RColorBrewer::brewer.pal(8, "RdBu"))(n = 100)))+
        theme_bw()


```  


```{r,results='asis', message= FALSE, echo = TRUE}
activity_test2 <- create_activity_data("Lef1", "Cell","cortex", data_cortex$TF_and_ext)[,2][[1]]
    
# add a activity column
forebrain_with_activity <- mutate(data_cortex$overall, activity_1 = activity_test2) 

ggplot(data = forebrain_with_activity, mapping = aes(x=UMAP1,y=UMAP2))+
        geom_point(aes(color = activity_1))+
        scale_color_gradientn(colors = rev(grDevices::colorRampPalette(RColorBrewer::brewer.pal(8, "RdBu"))(n = 100)))+
        theme_bw()

 
```

```{r,results='asis', message= FALSE, echo = TRUE}
activity_test2 <- create_activity_data("Lef1", "Cell","pons", data_pons$TF_and_ext)[,2][[1]]
    
# add a activity column
forebrain_with_activity <- mutate(data_pons$overall, activity_1 = activity_test2) 

ggplot(data = forebrain_with_activity, mapping = aes(x=UMAP1,y=UMAP2))+
        geom_point(aes(color = activity_1))+
        scale_color_gradientn(colors = rev(grDevices::colorRampPalette(RColorBrewer::brewer.pal(8, "RdBu"))(n = 100)))+
        theme_bw()

 
```




## 3. Time series plot
- discription: Given user's TF input, plot a time series trajectory of TF activity in pseudotime.
- **package**:  
```{r, message= FALSE}
library(shiny)
library(ggplot2)
```
- data: 4.TF_target_gene, 5. Activity per cluster, 6. Activity per cell
- input: a transcription factor, chosen from (3. Active TF data) vector TF_active
- output: A time series plot of TF activity in pseudotime
![alt text](data/image/timeseries_1.png)  
Here each dot corresponds to a cell and we can see the type from the colors.
However, in our plot, we are displaying TF activity so the y-axis should be TF activity instead of expression level.

## First, make color palette for plotting
```{r}

colour_palette <- metadata %>% 
  mutate(Cluster = gsub("_", " ", Cluster)) %>% 
  separate(Cluster, into = c("Prefix", "Cluster"), sep = " ") %>% 
  # Get two columns
  select(Cluster, Colour) %>% 
  distinct(Cluster, .keep_all = TRUE) %>% 
  # Convert to vector of colours, where the first column gives the names
  # and the second column is converted to the values
  deframe()
head(colour_palette)



```
load the cell metadata
```{r}
cell_metadata <- read_tsv("data/joint_cortex/joint_cortex.metadata.tsv") %>% 
  select(Age = orig.ident, Cell, Cluster = ID_20190730_with_blacklist_and_refined) %>% 
  # In this case, we remove the "prefix" of the Cluster column, so that we are
  # simply left with the abbreviation representing the cell type, so that 
  # we can link the cells of the same cell type across ages
  separate(Cluster, into = c("Prefix", "Cluster"), sep = "_") %>% 
  mutate(Age = factor(Age, levels = c("Forebrain E12.5",
                                      "Forebrain E15.5",
                                      "Forebrain P0",
                                      "Forebrain P3",
                                      "Forebrain P6"))) %>% 
  arrange(Cell)
head(cell_metadata)
```
Load the binary TF activity
```{r}

activity <- readRDS("data/joint_cortex/joint_cortex.binaryRegulonActivity_nonDupl.Rds")

activity[1:3, 1:3]

```
```{r}
# This step will change depending on the TF used
TF <- "Dlx1 (16g)" # input_tf

activity <- activity[TF, ] %>% 
  {data.frame("TF" = .)} %>% 
  tibble::rownames_to_column(var = "Cell") %>% # the original activity vector has names
  arrange(Cell)

```

Prep a tidy data frame:

```{r}

# Double check all Cell names are the same / in same order
all(cell_metadata$Cell == activity$Cell)

# Add the TF activity to the new dataframe
ribbon_df <- cell_metadata
ribbon_df$TF <- activity$TF

ribbon_df <- ribbon_df %>% 
  filter(!grepl("BLACKLIST", Cluster))

head(cell_metadata)

```

Make the plot:

```{r, fig.width = 10, fig.height = 8}

# Calculate for each cell type, the proportion of cells where the 
# TF is active
ribbon_df_celltype_frac <- ribbon_df %>% 
  group_by(Age) %>% 
  # Total cells at each age
  mutate(total = n()) %>% 
  group_by(Age, Cluster) %>%
  # Proportion of TF+ cells per cluster, per age
  mutate(frac = sum(TF > 0) / total) %>% 
  distinct(Age, Cluster, frac) %>% 
  ungroup()

ribbon_df_cum_frac <- ribbon_df %>% 
  group_by(Age) %>% 
  summarize(cumfrac = sum(TF > 0) / n()) %>% 
  ungroup()

timepoints2 <- ribbon_df$Age
clusters <- ribbon_df$Cluster

df = data.frame(cluster = rep(unique(clusters), length(unique(timepoints2))),
                stage = do.call(c, lapply(as.character(unique(timepoints2)), rep, times = length(unique(clusters)))))

df$ranking = match(df$cluster, names(colours))
df = df[order(df$stage, df$ranking),]

df <- left_join(df, select(ribbon_df_celltype_frac, cluster = Cluster, stage = Age, frac)) %>% 
  mutate(frac = replace_na(frac, 0)) %>% 
  left_join(select(ribbon_df_cum_frac, stage = Age, cumfrac))

df$xpos = match(df$stage, unique(timepoints2))

df %>%
  ggplot(aes(x = xpos, y = frac, fill = cluster)) +
  geom_area(stat = "identity") +
  scale_fill_manual(values = colour_palette, drop = FALSE, name = "") +
  scale_x_continuous(breaks = seq_along(unique(df$stage)),
                     labels = c("E12.5", "E15.5", "P0", "P3", "P6"),
                     limits = c(1, length(unique(df$stage)))) +
  labs(x = "age", y = "Binary activity", title = TF) +
  guides(fill = guide_legend(ncol = 5)) +
  theme(legend.position = "bottom")

```
Plot by **pseudotime**: cells that captured at same time will vary vastly in their stage in development progress. To avoid this problem, rather than ploting the changes according to the age, we plot as a function of progress with respect to each cell along its own trajectory, which we term "pseudotime".







